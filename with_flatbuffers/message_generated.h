// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_H_
#define FLATBUFFERS_GENERATED_MESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct Add;

struct Subtract;

struct AddReturnValue;

struct SubtractReturnValue;

struct Request;
struct RequestBuilder;

struct Response;
struct ResponseBuilder;

enum RequestType : int16_t {
  RequestType_Add = 0,
  RequestType_Subtract = 1,
  RequestType_MIN = RequestType_Add,
  RequestType_MAX = RequestType_Subtract
};

inline const RequestType (&EnumValuesRequestType())[2] {
  static const RequestType values[] = {
    RequestType_Add,
    RequestType_Subtract
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[3] = {
    "Add",
    "Subtract",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (::flatbuffers::IsOutRange(e, RequestType_Add, RequestType_Subtract)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum Command : uint8_t {
  Command_NONE = 0,
  Command_Add = 1,
  Command_Subtract = 2,
  Command_MIN = Command_NONE,
  Command_MAX = Command_Subtract
};

inline const Command (&EnumValuesCommand())[3] {
  static const Command values[] = {
    Command_NONE,
    Command_Add,
    Command_Subtract
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[4] = {
    "NONE",
    "Add",
    "Subtract",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command_NONE, Command_Subtract)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<Add> {
  static const Command enum_value = Command_Add;
};

template<> struct CommandTraits<Subtract> {
  static const Command enum_value = Command_Subtract;
};

bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ReturnValue : uint8_t {
  ReturnValue_NONE = 0,
  ReturnValue_AddReturnValue = 1,
  ReturnValue_SubtractReturnValue = 2,
  ReturnValue_MIN = ReturnValue_NONE,
  ReturnValue_MAX = ReturnValue_SubtractReturnValue
};

inline const ReturnValue (&EnumValuesReturnValue())[3] {
  static const ReturnValue values[] = {
    ReturnValue_NONE,
    ReturnValue_AddReturnValue,
    ReturnValue_SubtractReturnValue
  };
  return values;
}

inline const char * const *EnumNamesReturnValue() {
  static const char * const names[4] = {
    "NONE",
    "AddReturnValue",
    "SubtractReturnValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameReturnValue(ReturnValue e) {
  if (::flatbuffers::IsOutRange(e, ReturnValue_NONE, ReturnValue_SubtractReturnValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReturnValue()[index];
}

template<typename T> struct ReturnValueTraits {
  static const ReturnValue enum_value = ReturnValue_NONE;
};

template<> struct ReturnValueTraits<AddReturnValue> {
  static const ReturnValue enum_value = ReturnValue_AddReturnValue;
};

template<> struct ReturnValueTraits<SubtractReturnValue> {
  static const ReturnValue enum_value = ReturnValue_SubtractReturnValue;
};

bool VerifyReturnValue(::flatbuffers::Verifier &verifier, const void *obj, ReturnValue type);
bool VerifyReturnValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Add FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t a_;
  int32_t b_;

 public:
  Add()
      : a_(0),
        b_(0) {
  }
  Add(int32_t _a, int32_t _b)
      : a_(::flatbuffers::EndianScalar(_a)),
        b_(::flatbuffers::EndianScalar(_b)) {
  }
  int32_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  int32_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Add, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Subtract FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t a_;
  int32_t b_;

 public:
  Subtract()
      : a_(0),
        b_(0) {
  }
  Subtract(int32_t _a, int32_t _b)
      : a_(::flatbuffers::EndianScalar(_a)),
        b_(::flatbuffers::EndianScalar(_b)) {
  }
  int32_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  int32_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Subtract, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AddReturnValue FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;

 public:
  AddReturnValue()
      : value_(0) {
  }
  AddReturnValue(int32_t _value)
      : value_(::flatbuffers::EndianScalar(_value)) {
  }
  int32_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(AddReturnValue, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SubtractReturnValue FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;

 public:
  SubtractReturnValue()
      : value_(0) {
  }
  SubtractReturnValue(int32_t _value)
      : value_(::flatbuffers::EndianScalar(_value)) {
  }
  int32_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(SubtractReturnValue, 4);

struct Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REQUESTTYPE = 6,
    VT_COMMAND_TYPE = 8,
    VT_COMMAND = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  RequestType requestType() const {
    return static_cast<RequestType>(GetField<int16_t>(VT_REQUESTTYPE, 0));
  }
  Command command_type() const {
    return static_cast<Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const Add *command_as_Add() const {
    return command_type() == Command_Add ? static_cast<const Add *>(command()) : nullptr;
  }
  const Subtract *command_as_Subtract() const {
    return command_type() == Command_Subtract ? static_cast<const Subtract *>(command()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int16_t>(verifier, VT_REQUESTTYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Add *Request::command_as<Add>() const {
  return command_as_Add();
}

template<> inline const Subtract *Request::command_as<Subtract>() const {
  return command_as_Subtract();
}

struct RequestBuilder {
  typedef Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Request::VT_ID, id, 0);
  }
  void add_requestType(RequestType requestType) {
    fbb_.AddElement<int16_t>(Request::VT_REQUESTTYPE, static_cast<int16_t>(requestType), 0);
  }
  void add_command_type(Command command_type) {
    fbb_.AddElement<uint8_t>(Request::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Request::VT_COMMAND, command);
  }
  explicit RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request> CreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    RequestType requestType = RequestType_Add,
    Command command_type = Command_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_id(id);
  builder_.add_requestType(requestType);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REQUESTTYPE = 6,
    VT_RETURNVALUE_TYPE = 8,
    VT_RETURNVALUE = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  RequestType requestType() const {
    return static_cast<RequestType>(GetField<int16_t>(VT_REQUESTTYPE, 0));
  }
  ReturnValue returnValue_type() const {
    return static_cast<ReturnValue>(GetField<uint8_t>(VT_RETURNVALUE_TYPE, 0));
  }
  const void *returnValue() const {
    return GetPointer<const void *>(VT_RETURNVALUE);
  }
  template<typename T> const T *returnValue_as() const;
  const AddReturnValue *returnValue_as_AddReturnValue() const {
    return returnValue_type() == ReturnValue_AddReturnValue ? static_cast<const AddReturnValue *>(returnValue()) : nullptr;
  }
  const SubtractReturnValue *returnValue_as_SubtractReturnValue() const {
    return returnValue_type() == ReturnValue_SubtractReturnValue ? static_cast<const SubtractReturnValue *>(returnValue()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int16_t>(verifier, VT_REQUESTTYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_RETURNVALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RETURNVALUE) &&
           VerifyReturnValue(verifier, returnValue(), returnValue_type()) &&
           verifier.EndTable();
  }
};

template<> inline const AddReturnValue *Response::returnValue_as<AddReturnValue>() const {
  return returnValue_as_AddReturnValue();
}

template<> inline const SubtractReturnValue *Response::returnValue_as<SubtractReturnValue>() const {
  return returnValue_as_SubtractReturnValue();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Response::VT_ID, id, 0);
  }
  void add_requestType(RequestType requestType) {
    fbb_.AddElement<int16_t>(Response::VT_REQUESTTYPE, static_cast<int16_t>(requestType), 0);
  }
  void add_returnValue_type(ReturnValue returnValue_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RETURNVALUE_TYPE, static_cast<uint8_t>(returnValue_type), 0);
  }
  void add_returnValue(::flatbuffers::Offset<void> returnValue) {
    fbb_.AddOffset(Response::VT_RETURNVALUE, returnValue);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    RequestType requestType = RequestType_Add,
    ReturnValue returnValue_type = ReturnValue_NONE,
    ::flatbuffers::Offset<void> returnValue = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_returnValue(returnValue);
  builder_.add_id(id);
  builder_.add_requestType(requestType);
  builder_.add_returnValue_type(returnValue_type);
  return builder_.Finish();
}

inline bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_Add: {
      return verifier.VerifyField<Add>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case Command_Subtract: {
      return verifier.VerifyField<Subtract>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyReturnValue(::flatbuffers::Verifier &verifier, const void *obj, ReturnValue type) {
  switch (type) {
    case ReturnValue_NONE: {
      return true;
    }
    case ReturnValue_AddReturnValue: {
      return verifier.VerifyField<AddReturnValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ReturnValue_SubtractReturnValue: {
      return verifier.VerifyField<SubtractReturnValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    default: return true;
  }
}

inline bool VerifyReturnValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReturnValue(
        verifier,  values->Get(i), types->GetEnum<ReturnValue>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_MESSAGE_H_
